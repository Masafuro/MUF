# MUF (Multi-Unit Framework) プロトコル仕様書（ヘッダーレス版）

## 1. 概要
MUFプロトコルは、Redisのキー空間（Namespace）を階層構造として活用し、ユニット間通信、状態管理、およびデータの自浄作用（GC）を統合した軽量メッセージングプロトコルである。データ本体（Value）にメタデータを持たせず、すべての制御情報をキーパスに集約することで、高い視認性とRedis標準機能との親和性を実現する。

## 2. キー命名規則（Namespace）
全てのデータは以下の階層構造を持つキーによって識別される。
`MUF/[UNITNAME]/[STATUS]/[ID]`

| 階層 | 名称 | 内容 |
| :--- | :--- | :--- |
| 第1層 | **MUF** | プロトコルのルート識別子。 |
| 第2層 | **UNITNAME** | 発行元ユニットの一意な名称（例: `sensor-01`, `web-api`）。 |
| 第3層 | **STATUS** | 通信の状態。 `REQ`, `RES`, `ACK`, `ERR`, `KEEP` 等を使用。 |
| 第4層 | **ID** | メッセージの一意な識別子（SequenceID, SessionID, UUID等）。 |

## 3. データ本体（Value）
- **形式**: `FreeString` (UTF-8文字列, JSON, バイナリデータ等)。
- **仕様**: メタデータ（ヘッダー）は一切含まない。SDKは取得したデータをそのままユーザーデータとして扱う。

## 4. 有効期限（TTL）による自浄ルール
MUFプロトコルは、Redisの `EXPIRE` 機能を「自浄作用」の基幹として利用する。

- **デフォルト動作**: SDKはデータを投入する際、明示的な指定がない限り **5分間 (300秒)** のTTLを設定する。
- **一時通信（REQ/RES等）**: 短いTTLを設定し、ハンドシェイク完了後、またはタイムアウト後に自動消滅させる。
- **データ保持（KEEP等）**: セッション情報など長期保持が必要な場合は、SDKから長いTTL（例: 24時間）を指定して投入する。

## 5. 通信アーキテクチャ

### 5.1 イベント駆動（Keyspace Notifications）
バックエンドユニットは、Redisの **Keyspace Notifications (KN)** を利用して動作する。
- 監視パターン: `__keyspace@0__:MUF/*/REQ/*`
- 動作: 新規キー生成の通知を受けた瞬間に、対象キーから `UNITNAME` と `ID` を抽出し、データの処理を開始する。

### 5.2 抽象化API
SDKは以下の高レベルなインターフェースを提供する。
- `send(status, id, data, ttl=None)`: データをキーパスにパッキングして投入。
- `ans = get(id)`: 指定したIDに対する `RES` パスの出現を待機し、中身を返す。

## 6. 特徴とメリット
- **透明性**: `redis-cli` 等の標準ツールでキーの一覧を見るだけで、システム全体の稼働状況（どのユニットが何のリクエストを出しているか）が直感的に把握可能。
- **堅牢性**: 複雑なビット演算やGCロジックを排除し、Redisの標準機能に委譲することで、実装ミスによるメモリリークや不整合を最小限に抑える。
- **多言語対応**: ヘッダー解析が不要なため、Python, Go, Node.js, ブラウザJSなど、異なる環境間での連携が極めて容易。