# MUF (Memory Unit Framework) プロトコル仕様書 (v2.0 - Generic Unit版)

## 1. 概要

MUFプロトコルは、Redisのキー空間（Namespace）を階層的な共有メモリとして活用し、ユニット間の非同期通信と状態管理を統合した軽量メッセージングプロトコルです。最大の特徴は、すべての制御情報をキーパス自体に集約し、データ本体（Value）をヘッダーレスに保つ点にあります。本仕様では、システム内のすべてのパスを小文字（muf/）に強制正規化することで、物理レイヤーでの不整合を完全に排除しています。



## 2. キー空間設計（Namespace Hierarchy）

全てのデータは、以下の4階層で構成される一意なパスによって識別されます。
形式：`muf/[unit_name]/[status]/[id]`

### 2.1 階層の定義と正規化ルール

| 階層 | 名称 | 定義と役割 |
| :--- | :--- | :--- |
| 第1層 | root | `muf` 固定。システムのルート識別子。 |
| 第2層 | unit_name | データの所有者、あるいはリクエストの主体となるユニットの一意な名称。 |
| 第3層 | status | データの属性（req, res, err, keep）。詳細は後述。 |
| 第4層 | id | メッセージまたはセッションを識別する一意な文字列。 |

> **正規化の徹底**
> SDKは、Redisへアクセスするすべての工程においてパスを小文字（Lower-case）に変換します。これにより、開発者が大文字小文字の差異を意識することなく、確実に目的のデータへアクセスできる環境を保証します。

## 3. 通信ステータス（Status）の定義

| ステータス | 名称 | 役割の定義 |
| :--- | :--- | :--- |
| **req** | Request | 処理の依頼。依頼主の unit_name ディレクトリ配下に生成されます。 |
| **res** | Response | 成功の応答。依頼主の unit_name/res ディレクトリへ書き戻されます。 |
| **err** | Error | 異常の通知。resと同様のパスへ書き戻され、エラー内容を保持します。 |
| **keep** | State | 共有状態の保持。定常的なパラメータやステータス共有に使用します。 |

## 4. 有効期限（TTL）によるメモリ管理

MUFはRedisの `EXPIRE` 機能を、通信のタイムアウト制御および「残留データの自動清掃（GC）」に利用します。

### 4.1 標準TTL設定
SDKは、パス構築時に以下のデフォルト値を適用しますが、これらは実行時に個別に上書き可能です。
* **req**: 10秒（他ユニットが処理を開始するまでの猶予）
* **res / err**: 60秒（発行元が内容を確認し、モニターで観測するための猶予）
* **keep**: 3600秒（定常的な状態監視のための保持期間）

### 4.2 自動清掃（GC）の原則
処理が完了したデータを明示的に削除（DEL）する必要はありません。設定されたTTLが経過し、Redisによって物理的に消去されることを「正常なメモリ清掃」と定義します。

## 5. 通信シーケンス（RPC型）



1. **リクエスト発行側 (unit_a)**: `muf/unit_a/req/[id]` にデータを `SET ... EX 10` します。同時に、自分自身の空間にある `muf/unit_a/res/[id]` または `err` の生成を監視します。
2. **リクエスト処理側 (unit_b)**: `muf/*/req/*` を購読（PSUBSCRIBE）し、通知を受けた瞬間にリクエストを読み取ります。
3. **リクエスト処理側 (unit_b)**: 処理完了後、結果をリクエスト元の空間である `muf/unit_a/res/[id]`（成功時）または `muf/unit_a/err/[id]`（失敗時）へ `SET ... EX 60` します。
4. **リクエスト発行側 (unit_a)**: 通知を受けてレスポンスを取得し、自律的に次の処理へ遷移します。

## 6. 実装上の要件

SDKの実装においては、すべてのメソッド（`send`, `listen`, `parse_path`等）の冒頭でパス引数を小文字化し、DB上の不整合を未然に防ぐ「防衛的実装」を必須とします。また、Keyspace Notificationsの待機には非同期I/O（asyncio等）を用い、単一のユニットが複数のセッションを同時に並行処理できる構造を維持しなければなりません。